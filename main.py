import os
import re
import logging
import asyncio
from datetime import datetime
from io import BytesIO

import requests
from PIL import Image
from telegram import (
    Update,
    InlineKeyboardButton,
    InlineKeyboardMarkup,
    InputMediaAudio,
    InputMediaVideo,
    BotCommand
)
from telegram.ext import (
    Application,
    CommandHandler,
    MessageHandler,
    CallbackQueryHandler,
    ContextTypes,
    filters
)
from yt_dlp import YoutubeDL
from mutagen.mp3 import MP3
from mutagen.id3 import ID3, APIC, TIT2, TPE1, TALB
from moviepy.editor import VideoFileClip, AudioFileClip

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s", level=logging.INFO
)
logger = logging.getLogger(__name__)

# –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
PORT = int(os.environ.get("PORT", 5000))
TOKEN = os.environ["TOKEN"]
SUPPORT_CHAT_LINK = "https://t.me/freedom346"

# –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Å–æ—Å—Ç–æ—è–Ω–∏–µ–º
USER_STATES = {}
SEARCH_RESULTS = {}
SEARCH_PAGE = {}

# –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–µ –ø–ª–∞—Ç—Ñ–æ—Ä–º—ã
SUPPORTED_PLATFORMS = [
    "youtube.com", 
    "youtu.be",
    "pinterest.com",
    "yandex.ru",
    "vk.com",
    "tiktok.com",
    "instagram.com",
    "spotify.com"
]

class MediaProcessor:
    @staticmethod
    def download_media(url: str, media_type: str = "audio") -> tuple:
        ydl_opts = {
            "format": "bestaudio/best" if media_type == "audio" else "bestvideo+bestaudio",
            "outtmpl": "%(title)s.%(ext)s",
            "postprocessors": [{
                "key": "FFmpegExtractAudio",
                "preferredcodec": "mp3",
                "preferredquality": "192",
            }] if media_type == "audio" else [],
            "writethumbnail": True,
            "ignoreerrors": True
        }

        with YoutubeDL(ydl_opts) as ydl:
            info = ydl.extract_info(url, download=True)
            filename = ydl.prepare_filename(info)
            
            if media_type == "audio":
                filename = filename.replace(".webm", ".mp3").replace(".m4a", ".mp3")
            
            thumbnail_path = filename.rsplit(".", 1)[0] + ".webp"
            
            # –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º thumbnail –≤ JPG
            if os.path.exists(thumbnail_path):
                img = Image.open(thumbnail_path)
                jpg_path = thumbnail_path.replace(".webp", ".jpg")
                img.convert("RGB").save(jpg_path, "JPEG")
                thumbnail_path = jpg_path
            
            return filename, thumbnail_path, info

    @staticmethod
    def add_metadata(file_path: str, thumbnail_path: str, info: dict):
        if file_path.endswith(".mp3"):
            audio = MP3(file_path, ID3=ID3)
            try:
                audio.add_tags()
            except:
                pass

            audio.tags.add(
                APIC(
                    encoding=3,
                    mime="image/jpeg",
                    type=3,
                    desc="Cover",
                    data=open(thumbnail_path, "rb").read()
                )
            )
            audio.tags.add(TIT2(encoding=3, text=info.get("title", "")))
            audio.tags.add(TPE1(encoding=3, text=info.get("uploader", "")))
            audio.tags.add(TALB(encoding=3, text=info.get("album", "")))
            audio.save()

    @staticmethod
    def trim_media(file_path: str, start: float, end: float = None):
        output_path = file_path.replace(".", "_trimmed.")
        
        if file_path.endswith(".mp4") or file_path.endswith(".mkv"):
            clip = VideoFileClip(file_path).subclip(start, end)
            clip.write_videofile(output_path, codec="libx264", audio_codec="aac")
            clip.close()
        else:
            clip = AudioFileClip(file_path).subclip(start, end)
            clip.write_audiofile(output_path)
            clip.close()
            
        return output_path

    @staticmethod
    def parse_time(time_str: str) -> float:
        if ":" in time_str:
            parts = time_str.split(":")
            if len(parts) == 2:
                return float(parts[0]) * 60 + float(parts[1])
            elif len(parts) == 3:
                return float(parts[0]) * 3600 + float(parts[1]) * 60 + float(parts[2])
        return float(time_str)

# –ö–æ–º–∞–Ω–¥–∞ /start
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    welcome_text = (
        "üåü –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ Media Downloader Bot!\n\n"
        "–Ø –º–æ–≥—É —Å–∫–∞—á–∏–≤–∞—Ç—å –∫–æ–Ω—Ç–µ–Ω—Ç —Å —Ä–∞–∑–ª–∏—á–Ω—ã—Ö –ø–ª–∞—Ç—Ñ–æ—Ä–º:\n"
        "- YouTube\n- TikTok\n- Instagram\n- Spotify\n- VK\n- Pinterest\n- –Ø–Ω–¥–µ–∫—Å\n\n"
        "–ü—Ä–æ—Å—Ç–æ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –º–Ω–µ —Å—Å—ã–ª–∫—É –∏–ª–∏ –Ω–∞–∑–≤–∞–Ω–∏–µ —Ç—Ä–µ–∫–∞ –¥–ª—è –ø–æ–∏—Å–∫–∞!\n\n"
        "–ü–æ—Å–ª–µ —Å–∫–∞—á–∏–≤–∞–Ω–∏—è –≤—ã –º–æ–∂–µ—Ç–µ –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å —Ñ–∞–π–ª –∏–ª–∏ –æ–±—Ä–µ–∑–∞—Ç—å –µ–≥–æ.\n\n"
        f"–ü—Ä–∏—Å–æ–µ–¥–∏–Ω—è–π—Ç–µ—Å—å –∫ –Ω–∞—à–µ–º—É —á–∞—Ç—É: {SUPPORT_CHAT_LINK}"
    )
    
    await update.message.reply_text(
        welcome_text,
        reply_markup=InlineKeyboardMarkup([
            [InlineKeyboardButton("üîç –ü–æ–∏—Å–∫ –º—É–∑—ã–∫–∏", switch_inline_query_current_chat="")],
            [InlineKeyboardButton("üí¨ –ß–∞—Ç –ø–æ–¥–¥–µ—Ä–∂–∫–∏", url=SUPPORT_CHAT_LINK)]
        ])
    )

# –û–±—Ä–∞–±–æ—Ç—á–∏–∫ —Ç–µ–∫—Å—Ç–æ–≤—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π
async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_input = update.message.text
    chat_id = update.message.chat_id
    
    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ —Å—Å—ã–ª–∫—É
    if any(domain in user_input for domain in SUPPORTED_PLATFORMS):
        USER_STATES[chat_id] = {"url": user_input}
        await show_conversion_options(update)
    else:
        # –ü–æ–∏—Å–∫ –º—É–∑—ã–∫–∏
        await search_music(update, user_input)

# –ü–æ–∫–∞–∑–∞—Ç—å –≤–∞—Ä–∏–∞–Ω—Ç—ã –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏
async def show_conversion_options(update: Update):
    keyboard = [
        [
            InlineKeyboardButton("üéµ –ê—É–¥–∏–æ", callback_data="convert_audio"),
            InlineKeyboardButton("üé• –í–∏–¥–µ–æ", callback_data="convert_video"),
        ],
        [InlineKeyboardButton("‚ùå –û—Ç–º–µ–Ω–∞", callback_data="cancel")]
    ]
    
    await update.message.reply_text(
        "–í—ã–±–µ—Ä–∏—Ç–µ —Ñ–æ—Ä–º–∞—Ç –¥–ª—è —Å–∫–∞—á–∏–≤–∞–Ω–∏—è:",
        reply_markup=InlineKeyboardMarkup(keyboard)
    )

# –û–±—Ä–∞–±–æ—Ç–∫–∞ –≤—ã–±–æ—Ä–∞ –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏
async def handle_conversion_choice(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    chat_id = query.message.chat_id
    choice = query.data.split("_")[1]
    
    if choice == "cancel":
        await query.edit_message_text("–û–ø–µ—Ä–∞—Ü–∏—è –æ—Ç–º–µ–Ω–µ–Ω–∞.")
        return
    
    url = USER_STATES.get(chat_id, {}).get("url")
    if not url:
        await query.edit_message_text("–û—à–∏–±–∫–∞: URL –Ω–µ –Ω–∞–π–¥–µ–Ω.")
        return
    
    await query.edit_message_text(f"‚è≥ –ù–∞—á–∏–Ω–∞—é –æ–±—Ä–∞–±–æ—Ç–∫—É {'–∞—É–¥–∏–æ' if choice == 'audio' else '–≤–∏–¥–µ–æ'}...")
    
    try:
        file_path, thumbnail_path, info = MediaProcessor.download_media(url, choice)
        
        if choice == "audio":
            MediaProcessor.add_metadata(file_path, thumbnail_path, info)
        
        # –û—Ç–ø—Ä–∞–≤–∫–∞ —Ñ–∞–π–ª–∞
        with open(file_path, "rb") as media_file:
            caption = f"{info.get('title', '')}\n\n–ü—Ä–∏—Å–æ–µ–¥–∏–Ω—è–π—Ç–µ—Å—å –∫ –Ω–∞—à–µ–º—É —á–∞—Ç—É: {SUPPORT_CHAT_LINK}"
            
            if choice == "audio":
                await context.bot.send_audio(
                    chat_id,
                    audio=media_file,
                    caption=caption,
                    thumb=open(thumbnail_path, "rb") if os.path.exists(thumbnail_path) else None,
                    title=info.get("title", ""),
                    performer=info.get("uploader", "")
                )
            else:
                await context.bot.send_video(
                    chat_id,
                    video=media_file,
                    caption=caption,
                    thumb=open(thumbnail_path, "rb") if os.path.exists(thumbnail_path) else None,
                    supports_streaming=True
                )
        
        # –ü—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ –æ–±—Ä–µ–∑–∞—Ç—å —Ñ–∞–π–ª
        keyboard = [
            [InlineKeyboardButton("‚úÇÔ∏è –û–±—Ä–µ–∑–∞—Ç—å —Ñ–∞–π–ª", callback_data="trim_media")],
            [InlineKeyboardButton("‚úÖ –ì–æ—Ç–æ–≤–æ", callback_data="done")]
        ]
        
        await query.message.reply_text(
            "–§–∞–π–ª —É—Å–ø–µ—à–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω! –•–æ—Ç–∏—Ç–µ –æ–±—Ä–µ–∑–∞—Ç—å –µ–≥–æ?",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
        
        # –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ñ–∞–π–ª–µ
        USER_STATES[chat_id] = {
            "file_path": file_path,
            "media_type": choice,
            "info": info
        }
        
        # –£–¥–∞–ª–µ–Ω–∏–µ –≤—Ä–µ–º–µ–Ω–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤
        os.remove(file_path)
        if os.path.exists(thumbnail_path):
            os.remove(thumbnail_path)
            
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –º–µ–¥–∏–∞: {e}")
        await query.edit_message_text("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Ñ–∞–π–ª–∞.")

# –ü–æ–∏—Å–∫ –º—É–∑—ã–∫–∏
async def search_music(update: Update, query: str):
    chat_id = update.message.chat_id
    await update.message.reply_text(f"üîç –ò—â—É –º—É–∑—ã–∫—É –ø–æ –∑–∞–ø—Ä–æ—Å—É: {query}...")
    
    try:
        ydl_opts = {
            "format": "bestaudio/best",
            "default_search": "ytsearch10",
            "quiet": True
        }
        
        with YoutubeDL(ydl_opts) as ydl:
            info = ydl.extract_info(f"ytsearch10:{query}", download=False)
            if not info or "entries" not in info:
                await update.message.reply_text("–ù–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ üòî")
                return
                
            tracks = info["entries"]
            SEARCH_RESULTS[chat_id] = tracks
            SEARCH_PAGE[chat_id] = 0
            
            await show_search_results(update, chat_id, 0)
            
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–∏—Å–∫–∞: {e}")
        await update.message.reply_text("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–∏—Å–∫–µ.")

# –ü–æ–∫–∞–∑–∞—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –ø–æ–∏—Å–∫–∞
async def show_search_results(update: Update, chat_id: int, page: int):
    tracks = SEARCH_RESULTS.get(chat_id, [])
    if not tracks:
        return
        
    page_size = 5
    start_idx = page * page_size
    end_idx = min(start_idx + page_size, len(tracks))
    page_tracks = tracks[start_idx:end_idx]
    
    if not page_tracks:
        await update.message.reply_text("–ë–æ–ª—å—à–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –Ω–µ—Ç.")
        return
    
    keyboard = []
    for track in page_tracks:
        title = track.get("title", "–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è")[:30] + "..." if len(track.get("title", "")) > 30 else track.get("title", "–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è")
        keyboard.append([InlineKeyboardButton(
            f"üéµ {title}",
            callback_data=f"track_{track['id']}"
        )])
    
    # –ö–Ω–æ–ø–∫–∏ –Ω–∞–≤–∏–≥–∞—Ü–∏–∏
    nav_buttons = []
    if page > 0:
        nav_buttons.append(InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data=f"page_{page-1}"))
    if end_idx < len(tracks):
        nav_buttons.append(InlineKeyboardButton("–í–ø–µ—Ä–µ–¥ ‚ñ∂Ô∏è", callback_data=f"page_{page+1}"))
    
    if nav_buttons:
        keyboard.append(nav_buttons)
    
    keyboard.append([
        InlineKeyboardButton("‚¨áÔ∏è –°–∫–∞—á–∞—Ç—å –≤—Å–µ", callback_data="download_all"),
        InlineKeyboardButton("üéß –ê–ª—å–±–æ–º—ã", callback_data="albums")
    ])
    
    message_text = f"üîç –†–µ–∑—É–ª—å—Ç–∞—Ç—ã –ø–æ–∏—Å–∫–∞ (—Å—Ç—Ä–∞–Ω–∏—Ü–∞ {page+1}):"
    
    if update.callback_query:
        await update.callback_query.edit_message_text(
            message_text,
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
    else:
        await update.message.reply_text(
            message_text,
            reply_markup=InlineKeyboardMarkup(keyboard)
        )

# –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ–±—Ä–µ–∑–∫–∏ –º–µ–¥–∏–∞
async def handle_trim(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    chat_id = query.message.chat_id
    
    await query.edit_message_text(
        "‚úÇÔ∏è –í–≤–µ–¥–∏—Ç–µ –≤—Ä–µ–º–µ–Ω–Ω–æ–π –¥–∏–∞–ø–∞–∑–æ–Ω –¥–ª—è –æ–±—Ä–µ–∑–∫–∏ –≤ —Ñ–æ—Ä–º–∞—Ç–µ:\n"
        "–ü—Ä–∏–º–µ—Ä—ã:\n"
        "0 (–æ—Ç –Ω–∞—á–∞–ª–∞ –¥–æ –∫–æ–Ω—Ü–∞)\n"
        "5 (–æ—Ç 5 —Å–µ–∫—É–Ω–¥—ã –¥–æ –∫–æ–Ω—Ü–∞)\n"
        "2:33 (–æ—Ç 2:33 –¥–æ –∫–æ–Ω—Ü–∞)\n"
        "0-5 (–ø–µ—Ä–≤—ã–µ 5 —Å–µ–∫—É–Ω–¥)\n"
        "1:32-5:48 (–æ—Ç 1:32 –¥–æ 5:48)\n"
        "0.55-2:3.75 (–æ—Ç 55 —Å–æ—Ç—ã—Ö —Å–µ–∫—É–Ω–¥—ã –¥–æ 2 –º–∏–Ω—É—Ç 3 —Å–µ–∫—É–Ω–¥ –∏ 75 —Å–æ—Ç—ã—Ö)"
    )
    
    USER_STATES[chat_id]["waiting_for_trim"] = True

# –û–±—Ä–∞–±–æ—Ç–∫–∞ –≤–≤–æ–¥–∞ –≤—Ä–µ–º–µ–Ω–Ω–æ–≥–æ –¥–∏–∞–ø–∞–∑–æ–Ω–∞
async def handle_time_range(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.message.chat_id
    user_state = USER_STATES.get(chat_id, {})
    
    if not user_state.get("waiting_for_trim"):
        return
        
    time_range = update.message.text
    file_path = user_state.get("file_path")
    media_type = user_state.get("media_type")
    
    if not file_path or not media_type:
        await update.message.reply_text("–û—à–∏–±–∫–∞: –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Ñ–∞–π–ª–µ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç.")
        return
        
    try:
        if "-" in time_range:
            start_str, end_str = time_range.split("-")
            start_time = MediaProcessor.parse_time(start_str)
            end_time = MediaProcessor.parse_time(end_str)
        else:
            start_time = MediaProcessor.parse_time(time_range)
            end_time = None
            
        await update.message.reply_text("‚è≥ –û–±—Ä–µ–∑–∞—é —Ñ–∞–π–ª...")
        
        # –í—ã–ø–æ–ª–Ω—è–µ–º –æ–±—Ä–µ–∑–∫—É
        trimmed_path = MediaProcessor.trim_media(file_path, start_time, end_time)
        
        # –û—Ç–ø—Ä–∞–≤–∫–∞ –æ–±—Ä–µ–∑–∞–Ω–Ω–æ–≥–æ —Ñ–∞–π–ª–∞
        with open(trimmed_path, "rb") as media_file:
            caption = f"‚úÇÔ∏è –û–±—Ä–µ–∑–∞–Ω–Ω—ã–π —Ñ–∞–π–ª\n\n–ü—Ä–∏—Å–æ–µ–¥–∏–Ω—è–π—Ç–µ—Å—å –∫ –Ω–∞—à–µ–º—É —á–∞—Ç—É: {SUPPORT_CHAT_LINK}"
            
            if media_type == "audio":
                await context.bot.send_audio(
                    chat_id,
                    audio=media_file,
                    caption=caption
                )
            else:
                await context.bot.send_video(
                    chat_id,
                    video=media_file,
                    caption=caption,
                    supports_streaming=True
                )
        
        # –£–¥–∞–ª–µ–Ω–∏–µ –≤—Ä–µ–º–µ–Ω–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤
        os.remove(trimmed_path)
        if os.path.exists(file_path):
            os.remove(file_path)
            
        del USER_STATES[chat_id]["waiting_for_trim"]
        
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –æ–±—Ä–µ–∑–∫–∏: {e}")
        await update.message.reply_text("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –≤—Ä–µ–º–µ–Ω–Ω–æ–≥–æ –¥–∏–∞–ø–∞–∑–æ–Ω–∞.")

# –û–±—Ä–∞–±–æ—Ç–∫–∞ –∏–Ω–ª–∞–π–Ω-–∫–Ω–æ–ø–æ–∫
async def button_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    data = query.data
    chat_id = query.message.chat_id
    
    if data.startswith("convert_"):
        await handle_conversion_choice(update, context)
    elif data == "trim_media":
        await handle_trim(update, context)
    elif data.startswith("track_"):
        track_id = data.split("_")[1]
        await download_track(update, track_id)
    elif data.startswith("page_"):
        page = int(data.split("_")[1])
        SEARCH_PAGE[chat_id] = page
        await show_search_results(update, chat_id, page)
    elif data == "download_all":
        await download_all_tracks(update, chat_id)

# –°–∫–∞—á–∞—Ç—å –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–π —Ç—Ä–µ–∫
async def download_track(update: Update, track_id: str):
    query = update.callback_query
    chat_id = query.message.chat_id
    tracks = SEARCH_RESULTS.get(chat_id, [])
    
    track = next((t for t in tracks if t.get("id") == track_id), None)
    if not track:
        await query.edit_message_text("–¢—Ä–µ–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω.")
        return
        
    await query.edit_message_text(f"‚è≥ –°–∫–∞—á–∏–≤–∞—é: {track['title']}...")
    
    try:
        url = track.get("url") or f"https://youtu.be/{track_id}"
        file_path, thumbnail_path, info = MediaProcessor.download_media(url, "audio")
        MediaProcessor.add_metadata(file_path, thumbnail_path, info)
        
        with open(file_path, "rb") as audio_file:
            await context.bot.send_audio(
                chat_id,
                audio=audio_file,
                caption=f"üéµ {track['title']}\n\n–ü—Ä–∏—Å–æ–µ–¥–∏–Ω—è–π—Ç–µ—Å—å –∫ –Ω–∞—à–µ–º—É —á–∞—Ç—É: {SUPPORT_CHAT_LINK}",
                thumb=open(thumbnail_path, "rb") if os.path.exists(thumbnail_path) else None,
                title=track.get("title", ""),
                performer=track.get("uploader", "")
            )
        
        # –£–¥–∞–ª–µ–Ω–∏–µ –≤—Ä–µ–º–µ–Ω–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤
        os.remove(file_path)
        if os.path.exists(thumbnail_path):
            os.remove(thumbnail_path)
            
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ —Å–∫–∞—á–∏–≤–∞–Ω–∏—è —Ç—Ä–µ–∫–∞: {e}")
        await query.edit_message_text("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–∫–∞—á–∏–≤–∞–Ω–∏–∏ —Ç—Ä–µ–∫–∞.")

# –°–∫–∞—á–∞—Ç—å –≤—Å–µ —Ç—Ä–µ–∫–∏ –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–µ
async def download_all_tracks(update: Update, chat_id: int):
    query = update.callback_query
    await query.edit_message_text("‚è≥ –ù–∞—á–∏–Ω–∞—é —Å–∫–∞—á–∏–≤–∞–Ω–∏–µ –≤—Å–µ—Ö —Ç—Ä–µ–∫–æ–≤...")
    
    tracks = SEARCH_RESULTS.get(chat_id, [])
    page = SEARCH_PAGE.get(chat_id, 0)
    page_size = 5
    start_idx = page * page_size
    end_idx = min(start_idx + page_size, len(tracks))
    page_tracks = tracks[start_idx:end_idx]
    
    for track in page_tracks:
        try:
            url = track.get("url") or f"https://youtu.be/{track['id']}"
            file_path, thumbnail_path, info = MediaProcessor.download_media(url, "audio")
            MediaProcessor.add_metadata(file_path, thumbnail_path, info)
            
            with open(file_path, "rb") as audio_file:
                await context.bot.send_audio(
                    chat_id,
                    audio=audio_file,
                    caption=f"üéµ {track['title']}\n\n–ü—Ä–∏—Å–æ–µ–¥–∏–Ω—è–π—Ç–µ—Å—å –∫ –Ω–∞—à–µ–º—É —á–∞—Ç—É: {SUPPORT_CHAT_LINK}",
                    thumb=open(thumbnail_path, "rb") if os.path.exists(thumbnail_path) else None
                )
            
            os.remove(file_path)
            if os.path.exists(thumbnail_path):
                os.remove(thumbnail_path)
                
            await asyncio.sleep(2)  # –ó–∞–¥–µ—Ä–∂–∫–∞ –º–µ–∂–¥—É –æ—Ç–ø—Ä–∞–≤–∫–∞–º–∏
                
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ —Å–∫–∞—á–∏–≤–∞–Ω–∏—è —Ç—Ä–µ–∫–∞ {track['title']}: {e}")
            continue
    
    await query.edit_message_text("‚úÖ –í—Å–µ —Ç—Ä–µ–∫–∏ —Å—Ç—Ä–∞–Ω–∏—Ü—ã —É—Å–ø–µ—à–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω—ã!")

# –û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è
def main():
    application = Application.builder().token(TOKEN).build()
    
    # –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤
    application.add_handler(CommandHandler("start", start))
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))
    application.add_handler(CallbackQueryHandler(button_handler))
    application.add_handler(MessageHandler(filters.TEXT & filters.Regex(r"(\d+:\d+|\d+\.\d+|\d+)-?(\d+:\d+|\d+\.\d+|\d+)?"), handle_time_range))
    
    # –ó–∞–ø—É—Å–∫ –±–æ—Ç–∞ –Ω–∞ Render
    if "RENDER" in os.environ:
        application.run_webhook(
            listen="0.0.0.0",
            port=PORT,
            url_path=TOKEN,
            webhook_url=f"https://your-render-app-name.onrender.com/{TOKEN}"
        )
    else:
        application.run_polling()

if __name__ == "__main__":
    main()
